import argparse
import yaml
import os.path
import common

def html_header():
    returned = ""
    returned += "<html>\n"
    returned += "<body>\n"
    returned += "Feedback? Ideas? Complaints? Suggestions? Request for report about other area? <a href=\"https://www.openstreetmap.org/message/new/Mateusz%20Konieczny\">send me a message</a>!"
    returned += "<br />\n"
    returned += "---------------\n"
    returned +=  "<table>\n"
    return returned

def link_to_osm_object(url):
    return '<a href="' + url + '" target="_new">Affected OSM element that may be improved</a>'

def article_name_from_wikipedia_string(string):
    return string[string.find(":")+1:]

def language_code_from_wikipedia_string(string):
    return string[0:string.find(":")]

def format_wikipedia_link(string):
    if string == None:
        return "?"
    language_code = language_code_from_wikipedia_string(string)
    language_code = common.escape_from_internal_python_string_to_html_ascii(language_code)
    article_name = article_name_from_wikipedia_string(string)
    article_name = common.escape_from_internal_python_string_to_html_ascii(article_name)
    return '<a href="https://' + language_code + '.wikipedia.org/wiki/' + article_name + '" target="_new">' + language_code+":"+article_name + '</a>'

def table_row(text):
    returned = ""
    returned += "<tr>\n"
    returned += "<td>\n"
    returned += text
    returned += "</td>\n"
    returned += "</tr>\n"
    return returned

def parsed_args():
    parser = argparse.ArgumentParser(description='Production of webpage about validation of wikipedia tag in osm data.')
    parser.add_argument('-file', '-f', dest='file', type=str, help='name of yaml file produced by validator, consumed by this generator')
    parser.add_argument('-out', '-o', dest='out', type=str, help='main name part of html file (parameter should be without html extension).')
    args = parser.parse_args()
    if not (args.file):
        parser.error('Provide yaml file generated by wikipedia validator')
    return args

def get_errors(args):
    filepath = common.get_file_storage_location()+"/"+args.file
    if not os.path.isfile(filepath):
        print(filepath + " is not a file, provide an existing file")
        return []
    return common.load_data(filepath)

def error_description(e):
    returned = ""
    returned += table_row(common.htmlify(e['error_message']))
    returned += table_row(link_to_osm_object(e['osm_object_url']))
    if e['desired_wikipedia_target'] != None:
        returned += describe_proposed_relinking(e)
    returned += table_row( '-------' )
    return returned

def describe_proposed_relinking(e):
    returned = ""
    current = format_wikipedia_link(e['current_wikipedia_target'])
    to = format_wikipedia_link(e['desired_wikipedia_target'])
    if to == current:
        to = "?"
    returned += table_row( current + " -> " + to)
    if to != "?":
        article_name = article_name_from_wikipedia_string(e['desired_wikipedia_target'])
        returned += table_row( common.escape_from_internal_python_string_to_html_ascii(article_name))
    return returned

def generate_html_file(args, name_suffix, types):
    with open(args.out + name_suffix + '.html', 'w') as file:
        file.write(html_header())
        reported_errors = get_errors(args)
        for error_type_id in types:
            error_count = 0
            for e in reported_errors:
                if e['error_id'] == error_type_id:
                    error_count += 1
                    file.write(error_description(e))
            if error_count != 0:
                file.write(table_row( 'overpass query usable in JOSM that will load all objects with this error type:' ))
                query = common.get_query_for_loading_errors_by_category(filename = args.file, printed_error_ids = [error_type_id], format = "josm")
                file.write(table_row(common.escape_from_internal_python_string_to_html_ascii(query)))
                file.write(table_row( '==========' ))

        file.write("</table>")
        file.write("</body>")
        file.write("</html>")

def for_public_use():
    return [
        'wikipedia tag in outdated form and wikidata - mismatch',
        'wikipedia tag links to 404',
        'link to unlinkable article',
        'wikipedia wikidata mismatch',
        'should use wikipedia:subject',
        'wikipedia from wikipedia tag in outdated form - mismatch',
        'tag may be added based on wikidata',
        'duplicated link',
        'tag may be added based on wikidata - testing',
        'tag may be added based on wikidata - boring',
    ]

def for_private_use():
    return [
        'wikipedia tag unexpected language',
        'wikipedia from wikipedia tag in outdated form',
        'wikipedia from wikidata tag',
        'wikipedia wikidata mismatch - follow redirect',
    ]

def main():
    args = parsed_args()
    generate_html_file(args, "", for_public_use())
    generate_html_file(args, " - private", for_private_use())

if __name__ == "__main__":
    main()
